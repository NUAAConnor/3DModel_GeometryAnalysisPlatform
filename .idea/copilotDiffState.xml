<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/modules/ASGBuilder/ASGBuilder.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/modules/ASGBuilder/ASGBuilder.h" />
              <option name="originalContent" value="//&#10;// Created by zhuge on 2025/11/19.&#10;//&#10;&#10;#pragma once&#10;&#10;// ============================================================================&#10;// ASGBuilder.h&#10;// Refactored for Modern C++ (C++20) &amp; OpenCASCADE 7.9&#10;// ============================================================================&#10;&#10;#include &lt;string&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;map&gt;&#10;#include &lt;memory&gt; // smart pointers&#10;#include &lt;set&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;optional&gt; // C++17/20&#10;#include &lt;climits&gt;&#10;&#10;// ============== OpenCASCADE Core Headers ==============&#10;#include &lt;Standard_Handle.hxx&gt;&#10;#include &lt;Standard_Transient.hxx&gt;&#10;&#10;// Topological Data Structures&#10;#include &lt;TopoDS_Shape.hxx&gt;&#10;#include &lt;TopoDS_Face.hxx&gt;&#10;#include &lt;TopoDS_Edge.hxx&gt;&#10;#include &lt;TopoDS_Vertex.hxx&gt;&#10;#include &lt;TopoDS_Wire.hxx&gt;&#10;#include &lt;TopoDS.hxx&gt;&#10;#include &lt;TopLoc_Location.hxx&gt;&#10;#include &lt;TopExp_Explorer.hxx&gt;&#10;#include &lt;TopExp.hxx&gt;&#10;#include &lt;TopTools_IndexedMapOfShape.hxx&gt;&#10;#include &lt;TopTools_IndexedDataMapOfShapeListOfShape.hxx&gt;&#10;#include &lt;TopTools_ListOfShape.hxx&gt;&#10;&#10;// Geometry &amp; Math&#10;#include &lt;gp_Pnt.hxx&gt;&#10;#include &lt;gp_Dir.hxx&gt;&#10;#include &lt;gp_Vec.hxx&gt;&#10;#include &lt;gp_Ax1.hxx&gt;&#10;#include &lt;gp_Ax2.hxx&gt;&#10;#include &lt;gp_Pln.hxx&gt;&#10;#include &lt;gp_Cylinder.hxx&gt;&#10;#include &lt;Geom_Surface.hxx&gt;&#10;#include &lt;Geom_Curve.hxx&gt;&#10;&#10;// XDE / STEP Import&#10;#include &lt;TDocStd_Document.hxx&gt;&#10;#include &lt;XCAFDoc_ShapeTool.hxx&gt;&#10;#include &lt;TDF_Label.hxx&gt;&#10;&#10;namespace ASG&#10;{&#10;    // ============================================================================&#10;    // Constants&#10;    // ============================================================================&#10;&#10;    namespace Constants&#10;    {&#10;        /**&#10;         * @brief Distance tolerance used for radius comparisons and bounding-box enlargement&#10;         * @details Empirically tuned for STEP assemblies modeled in millimeters to keep feature grouping robust&#10;         */&#10;        constexpr double DistanceTolerance = 1e-6;&#10;&#10;        /**&#10;         * @brief Angular tolerance (radians) for axis, normal, and direction comparisons&#10;         * @details Prevents false-negative matches when aligning features under floating-point noise&#10;         */&#10;        constexpr double AngleTolerance = 1e-6;&#10;    }&#10;&#10;    // ============================================================================&#10;    // Enumerations&#10;    // ============================================================================&#10;&#10;    /**&#10;     * @brief Enumerates supported atomic surface primitives&#10;     * @details Used during surface classification; determines which geometric parameters are populated&#10;     */&#10;    enum class AtomType&#10;    {&#10;        PLANE,&#10;        CYLINDER,&#10;        CONE,&#10;        SPHERE,&#10;        TORUS,&#10;        BSPLINE,&#10;        OTHER&#10;    };&#10;&#10;    /**&#10;     * @brief Indicates whether a surface is convex, concave, or indeterminate relative to its solid&#10;     * @details Derived via curvature-center test and used to distinguish shafts vs. holes&#10;     */&#10;    enum class FormType&#10;    {&#10;        CONVEX,&#10;        CONCAVE,&#10;        NEUTRAL&#10;    };&#10;&#10;    /**&#10;     * @brief Classifies continuity between neighboring faces&#10;     * @details Encodes whether surfaces meet sharply (C0), tangentially (C1), smoothly (C2), or cannot be determined&#10;     */&#10;    enum class ContinuityType&#10;    {&#10;        C0,     //sharply&#10;        C1,     //tangentially&#10;        C2,     //smoothly&#10;        UNKNOWN     //cannot be determined&#10;    };&#10;&#10;    /**&#10;     * @brief Identifies high-level engineering features composed from atomic surfaces&#10;     * @details Used by composite recognition to tag holes, shafts, planar mates, and other semantic groups&#10;     */&#10;    enum class CompositeFeatureType&#10;    {&#10;        UNKNOWN,&#10;        HOLE,&#10;        SHAFT,&#10;        FUNCTIONAL_PLANE,&#10;        STEP_PLANE,&#10;    };&#10;&#10;    /**&#10;     * @brief Differentiates through-holes from blind holes&#10;     * @details Derived during hole recognition to support downstream tolerance reasoning&#10;     */&#10;    enum class HoleType&#10;    {&#10;        THROUGH,&#10;        BLIND,&#10;        UNKNOWN&#10;    };&#10;&#10;    /**&#10;     * @brief Enumerates supported assembly constraint relationships&#10;     * @details Produced by constraint matching and consumed by downstream solvers&#10;     */&#10;    enum class ConstraintType&#10;    {&#10;        COAXIAL,    // hole-shaft/hole-hole&#10;        COINCIDENT, // face2face&#10;        OFFSET      // face2face with distance(not used currently)&#10;    };&#10;&#10;    // ==========================================================================&#10;    // Data Structures&#10;    // ==========================================================================&#10;&#10;    /**&#10;     * @brief Captures a single assembly constraint between two composite features&#10;     * @details Provides part/feature identifiers plus type-specific numeric value for later graph export&#10;     */&#10;    struct AssemblyConstraint&#10;    {&#10;        ConstraintType type;&#10;&#10;        std::string partID_A;&#10;        std::string featureID_A;&#10;&#10;        std::string partID_B;&#10;        std::string featureID_B;&#10;&#10;        double value = 0.0;&#10;&#10;        [[nodiscard]] std::string ToString() const&#10;        {&#10;            std::string typeStr;&#10;            switch (type)&#10;            {&#10;            case ConstraintType::COAXIAL: typeStr = &quot;COAXIAL&quot;;&#10;                break;&#10;            case ConstraintType::COINCIDENT: typeStr = &quot;COINCIDENT&quot;;&#10;                break;&#10;            case ConstraintType::OFFSET: typeStr = &quot;OFFSET&quot;;&#10;                break;&#10;            }&#10;            return &quot;[&quot; + typeStr + &quot;] &quot; + partID_A + &quot;:&quot; + featureID_A + &quot; &lt;--&gt; &quot; + partID_B + &quot;:&quot; + featureID_B;&#10;        }&#10;    };&#10;&#10;    /**&#10;     * @brief Container for geometry parameters shared across all atomic feature types&#10;     * @details Holds axis, radii, height, and curvature values derived during IdentifyGeometryType&#10;     */&#10;    struct GeometricParams&#10;    {&#10;        gp_Dir axisVector;          // Normal for Plane, Axis for Cylinder/Cone&#10;        gp_Pnt locationPoint;       // Location for Plane, Axis Point for Cylinder&#10;        double radius = 0.0;        // Radius (Cylinder, Cone, Sphere)&#10;        double height = 0.0;        // Height/Depth along axis&#10;        double semiAngle = 0.0;     // Cone semi-angle&#10;        double majorRadius = 0.0;   // Torus&#10;        double minorRadius = 0.0;   // Torus&#10;        double curvature = 0.0;     // Pre-computed curvature feature (Mean Curvature approximation)&#10;    };&#10;&#10;    /**&#10;     * @brief Records adjacency metadata for a single neighboring face&#10;     * @details Stores neighbor identifier, continuity classification, and measured dihedral angle&#10;     */&#10;    struct AdjacencyInfo&#10;    {&#10;        std::string neighborFaceID;&#10;        ContinuityType continuityType = ContinuityType::UNKNOWN;&#10;        double dihedralAngle = 0.0;&#10;    };&#10;&#10;    /**&#10;     * @brief Describes a single atomic surface along with derived attributes&#10;     * @details Contains the OCC face handle, geometry classification, adjacency list, and fragment metadata&#10;     */&#10;    struct AtomicFeature&#10;    {&#10;        std::string faceID;&#10;        TopoDS_Face brepFace;&#10;        AtomType atomType = AtomType::OTHER;&#10;        GeometricParams geometricParams;&#10;        FormType formType = FormType::NEUTRAL;&#10;        std::vector&lt;AdjacencyInfo&gt; adjacencyList;&#10;        double area = 0.0;&#10;        bool isFunctional = true;&#10;        bool isFragment = false;&#10;        bool isMainFragment = false;&#10;        std::string logicalFeatureID;&#10;        double mergedArea = 0.0;&#10;        std::vector&lt;std::string&gt; fragmentFaceIDs;&#10;        bool isConsumed = false;&#10;    };&#10;&#10;    /**&#10;     * @brief Describes an engineering composite feature constructed from atomic surfaces&#10;     * @details Stores identifiers, geometry summaries, and child face relationships for graph export&#10;     */&#10;    struct CompositeFeature&#10;    {&#10;        std::string compositeID;&#10;        CompositeFeatureType type = CompositeFeatureType::UNKNOWN;&#10;        std::string partID;&#10;        std::vector&lt;std::string&gt; childAtomicFeatureIDs;&#10;        gp_Ax1 axis;&#10;        double nominalRadius = 0.0;&#10;        double height = 0.0;&#10;        gp_Dir planeNormal;&#10;        gp_Pnt planeLocation;&#10;        double planeArea = 0.0;&#10;        double width = 0.0;&#10;        HoleType holeSubType = HoleType::UNKNOWN;&#10;    };&#10;&#10;    /**&#10;     * @brief Key used to cluster fragmented faces that share the same underlying surface&#10;     * @details Combines the OCC surface handle with concavity state for use in ordered containers&#10;     */&#10;    struct MergeKey&#10;    {&#10;        Handle(Geom_Surface) surface;&#10;        FormType formType;&#10;&#10;        bool operator&lt;(const MergeKey&amp; other) const&#10;        {&#10;            if (surface.get() != other.surface.get())&#10;            {&#10;                return surface.get() &lt; other.surface.get();&#10;            }&#10;            return static_cast&lt;int&gt;(formType) &lt; static_cast&lt;int&gt;(other.formType);&#10;        }&#10;    };&#10;&#10;    /**&#10;     * @brief Represents a single part including raw shape data and derived features&#10;     * @details Holds the local B-Rep, transformation to world space, atomic features, and recognized composites&#10;     */&#10;    struct PartNode&#10;    {&#10;        std::string partID;&#10;        TopoDS_Shape brepShape;&#10;        gp_Trsf transformation;&#10;&#10;        // Use shared_ptr to prevent pointer invalidation when vector resizes&#10;        std::vector&lt;std::shared_ptr&lt;AtomicFeature&gt;&gt; atomicFeatures;&#10;&#10;        std::vector&lt;CompositeFeature&gt; compositeFeatures;&#10;&#10;        PartNode() = default;&#10;    };&#10;&#10;    /**&#10;     * @brief Flattened graph structure consumed by Python/GNN pipelines&#10;     * @details Captures node features, edge indices, and supervision labels exported via GetGraphDataForPart&#10;     */&#10;    struct DeepLearningGraphData&#10;    {&#10;        // Node feature channels&#10;        std::vector&lt;int&gt; nodeTypes;&#10;        std::vector&lt;double&gt; nodeAreas;&#10;        std::vector&lt;double&gt; nodeCurvatures;&#10;        std::vector&lt;double&gt; nodeCentroids;&#10;&#10;        // Edge index storage&#10;        std::vector&lt;int&gt; edgeSource;&#10;        std::vector&lt;int&gt; edgeTarget;&#10;&#10;        // Edge attributes&#10;        std::vector&lt;double&gt; edgeAngles;&#10;        std::vector&lt;int&gt; edgeContinuity;&#10;&#10;        // Supervision labels&#10;        std::vector&lt;int&gt; nodeLabelTypes;&#10;        std::vector&lt;int&gt; nodeLabelIndices;&#10;&#10;        [[nodiscard]] bool IsEmpty() const { return nodeTypes.empty(); }&#10;    };&#10;&#10;&#10;    // ============================================================================&#10;    // Main Class: ASGBuilder&#10;    // ============================================================================&#10;&#10;    class ASGBuilder&#10;    {&#10;    public:&#10;        /**&#10;         * @brief Construct ASGBuilder and allocate an XDE document for downstream import&#10;         * @details Instantiates the OCCT application context and prepares an empty document handle&#10;         * @return Initialized ASGBuilder instance ready for STEP loading&#10;         */&#10;        ASGBuilder();&#10;&#10;        /**&#10;         * @brief Destroy ASGBuilder and release document resources&#10;         * @details Closes the XDE document if allocated to avoid handle leaks&#10;         */&#10;        ~ASGBuilder();&#10;&#10;        /**&#10;         * @brief Load a STEP assembly into the internal XDE document&#10;         * @details Configures STEPCAF reader, transfers data, and populates shapeTool_&#10;         * @param filePath input: absolute or relative path to a STEP file&#10;         * @return output: true when reading/transferring succeed, otherwise false&#10;         */&#10;        [[nodiscard]] bool LoadAssemblyFromSTEP(const std::string&amp; filePath);&#10;&#10;        /**&#10;         * @brief Traverse the assembly tree and collect PartNode entries&#10;         * @details Uses shapeTool_ to find free shapes, recursing through assembly/component labels&#10;         */&#10;        void ParseAssemblyTree();&#10;&#10;        /**&#10;         * @brief Identify atomic features for every part in partNodes_&#10;         * @details Classifies each face, captures adjacency, and merges fragments prior to composite recognition&#10;         */&#10;        void ClassifyAtomicFeatures();&#10;&#10;        /**&#10;         * @brief Apply rule-based recognition to convert atomic features into composite features&#10;         * @details Detects holes, shafts, step planes, and functional planes by inspecting adjacency patterns&#10;         */&#10;        void RecognizeCompositeFeatures();&#10;&#10;        /**&#10;         * @brief Build the assembly constraint graph between recognized composite features&#10;         * @details Checks bounding boxes, matches coaxial/planar pairs, and stores resulting constraints&#10;         */&#10;        void BuildAssemblyConstraintGraph();&#10;&#10;        /**&#10;         * @brief Print part/feature counts to the console for quick diagnostics&#10;         */&#10;        void PrintStatistics() const;&#10;&#10;        /**&#10;         * @brief Serialize current analysis data to a JSON file&#10;         * @details Writes part IDs and composite feature summaries in a lightweight interchange format&#10;         * @param filePath input: destination JSON path&#10;         * @return output: true when file writing succeeds, false otherwise&#10;         */&#10;        [[nodiscard]] bool ExportToJSON(const std::string&amp; filePath) const;&#10;&#10;        /**&#10;         * @brief Simple linkage smoke test invoked from legacy entry points&#10;         * @details Currently emits a readiness message to stdout&#10;         */&#10;        static void runTest();&#10;&#10;        /**&#10;        * @brief Check whether the midpoint of a segment between two points lies inside the solid&#10;        * @details Used to distinguish slot vs. tongue by probing material occupancy&#10;        * @param p1 input: first sample point&#10;        * @param p2 input: second sample point&#10;        * @param solid input: solid used for inside-outside test&#10;        * @return output: true if midpoint is inside the solid, otherwise false&#10;        */&#10;        static bool IsMaterialBetween(const gp_Pnt&amp; p1, const gp_Pnt&amp; p2, const TopoDS_Shape&amp; solid);&#10;&#10;        /**&#10;         * @brief Retrieve the current list of inferred assembly constraints&#10;         * @return output: copy of the internal constraint vector&#10;         */&#10;        [[nodiscard]] std::vector&lt;AssemblyConstraint&gt; GetAssemblyConstraints() const { return constraints_; }&#10;&#10;        /**&#10;         * @brief Generate flattened graph data for a specific part ID&#10;         * @details Converts atomic features and adjacency information into arrays consumable by PyG&#10;         * @param partID input: identifier of the part to export&#10;         * @return output: populated DeepLearningGraphData structure (empty if part not found)&#10;         */&#10;        [[nodiscard]] DeepLearningGraphData GetGraphDataForPart(const std::string&amp; partID) const;&#10;&#10;    private:&#10;        // Internal logic helpers (Step 1)&#10;        /**&#10;         * @brief Recursively extract PartNode entries from an XDE label&#10;         * @details Handles both assembly and simple-shape labels while accumulating the applied transformation&#10;         * @param label input: XDE label under inspection&#10;         * @param transformation input: cumulative transformation from parent assemblies&#10;         */&#10;        void ExtractPartsFromLabel(const TDF_Label&amp; label, const gp_Trsf&amp; transformation);&#10;&#10;        // Internal logic helpers (Step 2)&#10;        /**&#10;         * @brief Classify every face in the given part into AtomicFeature records&#10;         * @details Computes geometry, concavity, area, adjacency, and fragment metadata for downstream processing&#10;         * @param partNode input/output: part structure receiving freshly computed atomicFeatures&#10;         */&#10;        void ClassifyPartAtomicFeatures(PartNode&amp; partNode);&#10;&#10;        /**&#10;         * @brief Merge atomic features that belong to the same analytical surface&#10;         * @details Collapses curved fragments into logical groups, assigning shared IDs and accumulated areas&#10;         */&#10;        void MergeFragmentedFeatures() const;&#10;&#10;        /**&#10;         * @brief Inspect the OCC surface backing a face and return its AtomType plus parameters&#10;         * @param face input: face whose geometry is analyzed&#10;         * @return output: pair of AtomType and filled GeometricParams&#10;         */&#10;        static std::pair&lt;AtomType, GeometricParams&gt; IdentifyGeometryType(const TopoDS_Face&amp; face);&#10;&#10;        /**&#10;         * @brief Determine whether a classified face is convex, concave, or neutral&#10;         * @param face input: target face&#10;         * @param atomType input: previously detected surface type&#10;         * @param geomParams input: geometry parameters including center point&#10;         * @param parentSolid input: solid used for inside/outside testing&#10;         * @return output: FormType result describing concavity&#10;         */&#10;        static FormType DetermineConcavity(&#10;            const TopoDS_Face&amp; face, const AtomType&amp; atomType,&#10;            const GeometricParams&amp; geomParams, const TopoDS_Shape&amp; parentSolid);&#10;&#10;        /**&#10;         * @brief Measure the dihedral angle between two faces sharing the same edge&#10;         * @details Evaluates normals at the edge midpoint and returns the angle in radians&#10;         */&#10;        static double ComputeEdgeDihedralAngle(const TopoDS_Edge&amp; edge, const TopoDS_Face&amp; f1, const TopoDS_Face&amp; f2);&#10;&#10;        /**&#10;         * @brief Build an adjacency list for the supplied face within a parent solid&#10;         * @details Iterates over incident edges, locates neighboring faces, and stores continuity and angles&#10;         * @param face input: face under analysis&#10;         * @param faceID input: identifier associated with the face&#10;         * @param parentSolid input: solid needed for edge-to-face mapping&#10;         * @return output: vector of AdjacencyInfo entries&#10;         */&#10;        std::vector&lt;AdjacencyInfo&gt; AnalyzeTopologicalAdjacency(&#10;            const TopoDS_Face&amp; face, const std::string&amp; faceID,&#10;            const TopoDS_Shape&amp; parentSolid);&#10;&#10;        // Internal logic helpers (Step 3)&#10;        // Using shared_ptr for map values to prevent pointer invalidation&#10;        using FeatureMap = std::map&lt;std::string, std::shared_ptr&lt;AtomicFeature&gt;&gt;;&#10;&#10;        /**&#10;         * @brief Recognize hole features composed of concave cylindrical surfaces&#10;         * @details Accepts candidate concave cylinders, optionally merges fragments, and records blind/through metadata&#10;         * @param partNode input/output: part that receives the new composite feature&#10;         * @param feature input: candidate atomic cylinder&#10;         * @param featureMap input/output: lookup table used to mark faces as consumed&#10;         * @return output: true if a hole feature was recognized, otherwise false&#10;         */&#10;        static bool RecognizeHoleFeature(PartNode&amp; partNode, const std::shared_ptr&lt;AtomicFeature&gt;&amp; feature, FeatureMap&amp; featureMap);&#10;&#10;        /**&#10;         * @brief Recognize shaft features composed of convex cylindrical surfaces&#10;         * @details Mirrors the hole logic but for protruding geometry used in mating conditions&#10;         * @param partNode input/output: part that receives the new composite feature&#10;         * @param feature input: candidate atomic cylinder&#10;         * @param featureMap input/output: lookup table used to mark faces as consumed&#10;         * @return output: true if a shaft feature was recognized, otherwise false&#10;         */&#10;        static bool RecognizeShaftFeature(PartNode&amp; partNode, const std::shared_ptr&lt;AtomicFeature&gt;&amp; feature, FeatureMap&amp; featureMap);&#10;&#10;        /**&#10;         * @brief Recognize step planes adjacent to cylindrical features via sharp (C0) edges&#10;         * @details Promotes neutral planes that neighbor cylinders into STEP_PLANE composites&#10;         * @param partNode input/output: owning part&#10;         * @param feature input: candidate atomic plane&#10;         * @param featureMap input/output: map used to find adjacent faces&#10;         * @return output: true if a step plane was recorded, otherwise false&#10;         */&#10;        static bool RecognizeStepPlaneFeature(PartNode&amp; partNode, const std::shared_ptr&lt;AtomicFeature&gt;&amp; feature, FeatureMap&amp; featureMap);&#10;&#10;        /**&#10;         * @brief Recognize functional planes that remain unconsumed yet exceed area/importance thresholds&#10;         * @details Acts as a catch-all to ensure significant planar surfaces are captured for mating relations&#10;         * @param partNode input/output: owning part&#10;         * @param feature input: candidate atomic plane&#10;         * @param featureMap input/output: map used for state tracking&#10;         * @return output: true if the plane was promoted to a composite feature, otherwise false&#10;         */&#10;        static bool RecognizeFunctionalPlaneFeature(PartNode&amp; partNode, const std::shared_ptr&lt;AtomicFeature&gt;&amp; feature,&#10;                                                    FeatureMap&amp; featureMap);&#10;&#10;        /**&#10;         * @brief Compute the surface area of a given face&#10;         * @details Uses BRepGProp to calculate the precise surface area via mass properties&#10;         * @param face input: face whose area is measured&#10;         * @return output: surface area in square units (typically mmÂ²)&#10;         */&#10;        static double ComputeFaceArea(const TopoDS_Face&amp; face);&#10;&#10;        /**&#10;         * @brief Sample a representative point on the face surface&#10;         * @details Evaluates the face at the midpoint of its UV parameter domain&#10;         * @param face input: face from which to extract a sample point&#10;         * @return output: 3D point in world coordinates&#10;         */&#10;        static gp_Pnt GetFaceSamplePoint(const TopoDS_Face&amp; face);&#10;&#10;        /**&#10;         * @brief Measure the height of a cylindrical face along its axis&#10;         * @details Projects all edge vertices onto the axis and computes the span distance&#10;         * @param face input: cylindrical face to measure&#10;         * @param axisPoint input: reference point on the cylinder axis&#10;         * @param axisVector input: direction vector of the cylinder axis&#10;         * @return output: height measured along the axis direction&#10;         */&#10;        static double ComputeCylinderHeight(const TopoDS_Face&amp; face, const gp_Pnt&amp; axisPoint, const gp_Dir&amp; axisVector);&#10;&#10;        /**&#10;         * @brief Evaluate all feature pairs between two parts and record compatible constraints&#10;         * @details Iterates over composite features in both parts and delegates to coaxial/planar matchers&#10;         * @param nodeA input: first part in the pair&#10;         * @param nodeB input: second part in the pair&#10;         */&#10;        void MatchPartPair(const PartNode&amp; nodeA, const PartNode&amp; nodeB);&#10;&#10;        /**&#10;         * @brief Test whether two cylindrical features form a valid coaxial constraint&#10;         * @details Checks axis parallelism, distance from axis, and radius compatibility&#10;         * @param nodeA input: part containing the first feature&#10;         * @param featA input: first cylindrical feature (hole or shaft)&#10;         * @param nodeB input: part containing the second feature&#10;         * @param featB input: second cylindrical feature (hole or shaft)&#10;         */&#10;        void MatchCoaxial(const PartNode&amp; nodeA, const CompositeFeature&amp; featA,&#10;                          const PartNode&amp; nodeB, const CompositeFeature&amp; featB);&#10;&#10;        /**&#10;         * @brief Test whether two planar features form a valid coincident constraint&#10;         * @details Verifies that normals are opposite, planes are co-planar, and bounding boxes overlap&#10;         * @param nodeA input: part containing the first feature&#10;         * @param featA input: first planar feature (functional or step plane)&#10;         * @param nodeB input: part containing the second feature&#10;         * @param featB input: second planar feature (functional or step plane)&#10;         */&#10;        void MatchCoincident(const PartNode&amp; nodeA, const CompositeFeature&amp; featA,&#10;                             const PartNode&amp; nodeB, const CompositeFeature&amp; featB);&#10;&#10;        /**&#10;         * @brief Transform a local axis to world coordinates using the provided transformation&#10;         * @details Applies the gp_Trsf to both the axis location and direction&#10;         * @param localAxis input: axis in part-local coordinates&#10;         * @param trsf input: transformation matrix from local to world space&#10;         * @return output: transformed axis in world coordinates&#10;         */&#10;        static gp_Ax1 TransformAxis(const gp_Ax1&amp; localAxis, const gp_Trsf&amp; trsf);&#10;&#10;        /**&#10;         * @brief Transform a local point to world coordinates using the provided transformation&#10;         * @details Applies the gp_Trsf to the point coordinates&#10;         * @param localPnt input: point in part-local coordinates&#10;         * @param trsf input: transformation matrix from local to world space&#10;         * @return output: transformed point in world coordinates&#10;         */&#10;        static gp_Pnt TransformPoint(const gp_Pnt&amp; localPnt, const gp_Trsf&amp; trsf);&#10;&#10;        /**&#10;         * @brief Transform a local direction vector to world coordinates using the provided transformation&#10;         * @details Applies the gp_Trsf to the direction components (ignores translation)&#10;         * @param localDir input: direction in part-local coordinates&#10;         * @param trsf input: transformation matrix from local to world space&#10;         * @return output: transformed direction in world coordinates&#10;         */&#10;        static gp_Dir TransformDir(const gp_Dir&amp; localDir, const gp_Trsf&amp; trsf);&#10;&#10;        /**&#10;         * @brief Perform broad-phase collision detection between two parts using axis-aligned bounding boxes&#10;         * @details Computes bounding boxes in world space, enlarges by tolerance, and tests for overlap&#10;         * @param nodeA input: first part to test&#10;         * @param nodeB input: second part to test&#10;         * @return output: true if bounding boxes overlap (potential contact), otherwise false&#10;         */&#10;        static bool CheckBoundingBoxCollision(const PartNode&amp; nodeA, const PartNode&amp; nodeB);&#10;&#10;        // Member Data&#10;        Handle(TDocStd_Document) doc_;              // XDE document holding the imported STEP assembly&#10;        Handle(XCAFDoc_ShapeTool) shapeTool_;      // XDE shape tool for navigating the assembly hierarchy&#10;&#10;        std::vector&lt;PartNode&gt; partNodes_;           // Collection of all extracted parts with their features&#10;&#10;        // Custom comparator for using TopoDS_Face as a map key&#10;        struct FaceComparator&#10;        {&#10;            bool operator()(const TopoDS_Face&amp; f1, const TopoDS_Face&amp; f2) const&#10;            {&#10;                // 1. Compare TShape pointers&#10;                if (f1.TShape().get() != f2.TShape().get())&#10;                {&#10;                    return f1.TShape().get() &lt; f2.TShape().get();&#10;                }&#10;&#10;                // 2. Compare Location Hash&#10;                const int h1 = static_cast&lt;int&gt;(f1.Location().HashCode());&#10;&#10;                if (const int h2 = static_cast&lt;int&gt;(f2.Location().HashCode()); h1 != h2)&#10;                {&#10;                    return h1 &lt; h2;&#10;                }&#10;&#10;                // 3. Compare Orientation&#10;                return f1.Orientation() &lt; f2.Orientation();&#10;            }&#10;        };&#10;&#10;        std::map&lt;TopoDS_Face, std::string, FaceComparator&gt; faceIDMap_;  // Bidirectional lookup: face to unique ID&#10;&#10;        /**&#10;         * @brief Store the list of assembly constraints discovered during graph construction&#10;         * @details Populated by BuildAssemblyConstraintGraph and consumed by downstream clients&#10;         */&#10;        std::vector&lt;AssemblyConstraint&gt; constraints_;&#10;    };&#10;} // namespace ASG&#10;" />
              <option name="updatedContent" value="//&#10;// Created by zhuge on 2025/11/19.&#10;//&#10;&#10;#pragma once&#10;&#10;// ============================================================================&#10;// ASGBuilder.h&#10;// Refactored for Modern C++ (C++20) &amp; OpenCASCADE 7.9&#10;// ============================================================================&#10;&#10;#include &lt;string&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;map&gt;&#10;#include &lt;memory&gt; // smart pointers&#10;#include &lt;set&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;optional&gt; // C++17/20&#10;#include &lt;climits&gt;&#10;&#10;// ============== OpenCASCADE Core Headers ==============&#10;#include &lt;Standard_Handle.hxx&gt;&#10;#include &lt;Standard_Transient.hxx&gt;&#10;&#10;// Topological Data Structures&#10;#include &lt;TopoDS_Shape.hxx&gt;&#10;#include &lt;TopoDS_Face.hxx&gt;&#10;#include &lt;TopoDS_Edge.hxx&gt;&#10;#include &lt;TopoDS_Vertex.hxx&gt;&#10;#include &lt;TopoDS_Wire.hxx&gt;&#10;#include &lt;TopoDS.hxx&gt;&#10;#include &lt;TopLoc_Location.hxx&gt;&#10;#include &lt;TopExp_Explorer.hxx&gt;&#10;#include &lt;TopExp.hxx&gt;&#10;#include &lt;TopTools_IndexedMapOfShape.hxx&gt;&#10;#include &lt;TopTools_IndexedDataMapOfShapeListOfShape.hxx&gt;&#10;#include &lt;TopTools_ListOfShape.hxx&gt;&#10;&#10;// Geometry &amp; Math&#10;#include &lt;gp_Pnt.hxx&gt;&#10;#include &lt;gp_Dir.hxx&gt;&#10;#include &lt;gp_Vec.hxx&gt;&#10;#include &lt;gp_Ax1.hxx&gt;&#10;#include &lt;gp_Ax2.hxx&gt;&#10;#include &lt;gp_Pln.hxx&gt;&#10;#include &lt;gp_Cylinder.hxx&gt;&#10;#include &lt;Geom_Surface.hxx&gt;&#10;#include &lt;Geom_Curve.hxx&gt;&#10;&#10;// XDE / STEP Import&#10;#include &lt;TDocStd_Document.hxx&gt;&#10;#include &lt;XCAFDoc_ShapeTool.hxx&gt;&#10;#include &lt;TDF_Label.hxx&gt;&#10;&#10;namespace ASG&#10;{&#10;    // ============================================================================&#10;    // Constants&#10;    // ============================================================================&#10;&#10;    namespace Constants&#10;    {&#10;        /**&#10;         * @brief Distance tolerance used for radius comparisons and bounding-box enlargement&#10;         * @details Empirically tuned for STEP assemblies modeled in millimeters to keep feature grouping robust&#10;         */&#10;        constexpr double DistanceTolerance = 1e-6;&#10;&#10;        /**&#10;         * @brief Angular tolerance (radians) for axis, normal, and direction comparisons&#10;         * @details Prevents false-negative matches when aligning features under floating-point noise&#10;         */&#10;        constexpr double AngleTolerance = 1e-6;&#10;    }&#10;&#10;    // ============================================================================&#10;    // Enumerations&#10;    // ============================================================================&#10;&#10;    /**&#10;     * @brief Enumerates supported atomic surface primitives&#10;     * @details Used during surface classification; determines which geometric parameters are populated&#10;     */&#10;    enum class AtomType&#10;    {&#10;        PLANE,&#10;        CYLINDER,&#10;        CONE,&#10;        SPHERE,&#10;        TORUS,&#10;        BSPLINE,&#10;        OTHER&#10;    };&#10;&#10;    /**&#10;     * @brief Indicates whether a surface is convex, concave, or indeterminate relative to its solid&#10;     * @details Derived via curvature-center test and used to distinguish shafts vs. holes&#10;     */&#10;    enum class FormType&#10;    {&#10;        CONVEX,&#10;        CONCAVE,&#10;        NEUTRAL&#10;    };&#10;&#10;    /**&#10;     * @brief Classifies continuity between neighboring faces&#10;     * @details Encodes whether surfaces meet sharply (C0), tangentially (C1), smoothly (C2), or cannot be determined&#10;     */&#10;    enum class ContinuityType&#10;    {&#10;        C0,     //sharply&#10;        C1,     //tangentially&#10;        C2,     //smoothly&#10;        UNKNOWN     //cannot be determined&#10;    };&#10;&#10;    /**&#10;     * @brief Identifies high-level engineering features composed from atomic surfaces&#10;     * @details Used by composite recognition to tag holes, shafts, planar mates, and other semantic groups&#10;     */&#10;    enum class CompositeFeatureType&#10;    {&#10;        UNKNOWN,&#10;        HOLE,&#10;        SHAFT,&#10;        FUNCTIONAL_PLANE,&#10;        STEP_PLANE,&#10;    };&#10;&#10;    /**&#10;     * @brief Differentiates through-holes from blind holes&#10;     * @details Derived during hole recognition to support downstream tolerance reasoning&#10;     */&#10;    enum class HoleType&#10;    {&#10;        THROUGH,&#10;        BLIND,&#10;        UNKNOWN&#10;    };&#10;&#10;    /**&#10;     * @brief Enumerates supported assembly constraint relationships&#10;     * @details Produced by constraint matching and consumed by downstream solvers&#10;     */&#10;    enum class ConstraintType&#10;    {&#10;        COAXIAL,    // hole-shaft/hole-hole&#10;        COINCIDENT, // face2face&#10;        OFFSET      // face2face with distance(not used currently)&#10;    };&#10;&#10;    // ==========================================================================&#10;    // Data Structures&#10;    // ==========================================================================&#10;&#10;    /**&#10;     * @brief Captures a single assembly constraint between two composite features&#10;     * @details Provides part/feature identifiers plus type-specific numeric value for later graph export&#10;     */&#10;    struct AssemblyConstraint&#10;    {&#10;        ConstraintType type;&#10;&#10;        std::string partID_A;&#10;        std::string featureID_A;&#10;&#10;        std::string partID_B;&#10;        std::string featureID_B;&#10;&#10;        double value = 0.0;&#10;&#10;        [[nodiscard]] std::string ToString() const&#10;        {&#10;            std::string typeStr;&#10;            switch (type)&#10;            {&#10;            case ConstraintType::COAXIAL: typeStr = &quot;COAXIAL&quot;;&#10;                break;&#10;            case ConstraintType::COINCIDENT: typeStr = &quot;COINCIDENT&quot;;&#10;                break;&#10;            case ConstraintType::OFFSET: typeStr = &quot;OFFSET&quot;;&#10;                break;&#10;            }&#10;            return &quot;[&quot; + typeStr + &quot;] &quot; + partID_A + &quot;:&quot; + featureID_A + &quot; &lt;--&gt; &quot; + partID_B + &quot;:&quot; + featureID_B;&#10;        }&#10;    };&#10;&#10;    /**&#10;     * @brief Container for geometry parameters shared across all atomic feature types&#10;     * @details Holds axis, radii, height, and curvature values derived during IdentifyGeometryType&#10;     */&#10;    struct GeometricParams&#10;    {&#10;        gp_Dir axisVector;          // Normal for Plane, Axis for Cylinder/Cone&#10;        gp_Pnt locationPoint;       // Location for Plane, Axis Point for Cylinder&#10;        double radius = 0.0;        // Radius (Cylinder, Cone, Sphere)&#10;        double height = 0.0;        // Height/Depth along axis&#10;        double semiAngle = 0.0;     // Cone semi-angle&#10;        double majorRadius = 0.0;   // Torus&#10;        double minorRadius = 0.0;   // Torus&#10;        double curvature = 0.0;     // Pre-computed curvature feature (Mean Curvature approximation)&#10;    };&#10;&#10;    /**&#10;     * @brief Records adjacency metadata for a single neighboring face&#10;     * @details Stores neighbor identifier, continuity classification, and measured dihedral angle&#10;     */&#10;    struct AdjacencyInfo&#10;    {&#10;        std::string neighborFaceID;&#10;        ContinuityType continuityType = ContinuityType::UNKNOWN;&#10;        double dihedralAngle = 0.0;&#10;    };&#10;&#10;    /**&#10;     * @brief Describes a single atomic surface along with derived attributes&#10;     * @details Contains the OCC face handle, geometry classification, adjacency list, and fragment metadata&#10;     */&#10;    struct AtomicFeature&#10;    {&#10;        std::string faceID;&#10;        TopoDS_Face brepFace;&#10;        AtomType atomType = AtomType::OTHER;&#10;        GeometricParams geometricParams;&#10;        FormType formType = FormType::NEUTRAL;&#10;        std::vector&lt;AdjacencyInfo&gt; adjacencyList;&#10;        double area = 0.0;&#10;        bool isFunctional = true;&#10;        bool isFragment = false;&#10;        bool isMainFragment = false;&#10;        std::string logicalFeatureID;&#10;        double mergedArea = 0.0;&#10;        std::vector&lt;std::string&gt; fragmentFaceIDs;&#10;        bool isConsumed = false;&#10;    };&#10;&#10;    /**&#10;     * @brief Describes an engineering composite feature constructed from atomic surfaces&#10;     * @details Stores identifiers, geometry summaries, and child face relationships for graph export&#10;     */&#10;    struct CompositeFeature&#10;    {&#10;        std::string compositeID;&#10;        CompositeFeatureType type = CompositeFeatureType::UNKNOWN;&#10;        std::string partID;&#10;        std::vector&lt;std::string&gt; childAtomicFeatureIDs;&#10;        gp_Ax1 axis;&#10;        double nominalRadius = 0.0;&#10;        double height = 0.0;&#10;        gp_Dir planeNormal;&#10;        gp_Pnt planeLocation;&#10;        double planeArea = 0.0;&#10;        double width = 0.0;&#10;        HoleType holeSubType = HoleType::UNKNOWN;&#10;    };&#10;&#10;    /**&#10;     * @brief Key used to cluster fragmented faces that share the same underlying surface&#10;     * @details Combines the OCC surface handle with concavity state for use in ordered containers&#10;     */&#10;    struct MergeKey&#10;    {&#10;        Handle(Geom_Surface) surface;&#10;        FormType formType;&#10;&#10;        bool operator&lt;(const MergeKey&amp; other) const&#10;        {&#10;            if (surface.get() != other.surface.get())&#10;            {&#10;                return surface.get() &lt; other.surface.get();&#10;            }&#10;            return static_cast&lt;int&gt;(formType) &lt; static_cast&lt;int&gt;(other.formType);&#10;        }&#10;    };&#10;&#10;    /**&#10;     * @brief Represents a single part including raw shape data and derived features&#10;     * @details Holds the local B-Rep, transformation to world space, atomic features, and recognized composites&#10;     */&#10;    struct PartNode&#10;    {&#10;        std::string partID;&#10;        TopoDS_Shape brepShape;&#10;        gp_Trsf transformation;&#10;&#10;        // Use shared_ptr to prevent pointer invalidation when vector resizes&#10;        std::vector&lt;std::shared_ptr&lt;AtomicFeature&gt;&gt; atomicFeatures;&#10;&#10;        std::vector&lt;CompositeFeature&gt; compositeFeatures;&#10;&#10;        PartNode() = default;&#10;    };&#10;&#10;    /**&#10;     * @brief Flattened graph structure consumed by Python/GNN pipelines&#10;     * @details Captures node features, edge indices, and supervision labels exported via GetGraphDataForPart&#10;     */&#10;    struct DeepLearningGraphData&#10;    {&#10;        // Node feature channels&#10;        std::vector&lt;int&gt; nodeTypes;&#10;        std::vector&lt;double&gt; nodeAreas;&#10;        std::vector&lt;double&gt; nodeCurvatures;&#10;        std::vector&lt;double&gt; nodeCentroids;&#10;&#10;        // Edge index storage&#10;        std::vector&lt;int&gt; edgeSource;&#10;        std::vector&lt;int&gt; edgeTarget;&#10;&#10;        // Edge attributes&#10;        std::vector&lt;double&gt; edgeAngles;&#10;        std::vector&lt;int&gt; edgeContinuity;&#10;&#10;        // Supervision labels&#10;        std::vector&lt;int&gt; nodeLabelTypes;&#10;        std::vector&lt;int&gt; nodeLabelIndices;&#10;&#10;        [[nodiscard]] bool IsEmpty() const { return nodeTypes.empty(); }&#10;    };&#10;&#10;&#10;    // ============================================================================&#10;    // Main Class: ASGBuilder&#10;    // ============================================================================&#10;&#10;    class ASGBuilder&#10;    {&#10;    public:&#10;        /**&#10;         * @brief Construct ASGBuilder and allocate an XDE document for downstream import&#10;         * @details Instantiates the OCCT application context and prepares an empty document handle&#10;         * @return Initialized ASGBuilder instance ready for STEP loading&#10;         */&#10;        ASGBuilder();&#10;&#10;        /**&#10;         * @brief Destroy ASGBuilder and release document resources&#10;         * @details Closes the XDE document if allocated to avoid handle leaks&#10;         */&#10;        ~ASGBuilder();&#10;&#10;        /**&#10;         * @brief Load a STEP assembly into the internal XDE document&#10;         * @details Configures STEPCAF reader, transfers data, and populates shapeTool_&#10;         * @param filePath input: absolute or relative path to a STEP file&#10;         * @return output: true when reading/transferring succeed, otherwise false&#10;         */&#10;        [[nodiscard]] bool LoadAssemblyFromSTEP(const std::string&amp; filePath);&#10;&#10;        /**&#10;         * @brief Traverse the assembly tree and collect PartNode entries&#10;         * @details Uses shapeTool_ to find free shapes, recursing through assembly/component labels&#10;         */&#10;        void ParseAssemblyTree();&#10;&#10;        /**&#10;         * @brief Identify atomic features for every part in partNodes_&#10;         * @details Classifies each face, captures adjacency, and merges fragments prior to composite recognition&#10;         */&#10;        void ClassifyAtomicFeatures();&#10;&#10;        /**&#10;         * @brief Apply rule-based recognition to convert atomic features into composite features&#10;         * @details Detects holes, shafts, step planes, and functional planes by inspecting adjacency patterns&#10;         */&#10;        void RecognizeCompositeFeatures();&#10;&#10;        /**&#10;         * @brief Build the assembly constraint graph between recognized composite features&#10;         * @details Checks bounding boxes, matches coaxial/planar pairs, and stores resulting constraints&#10;         */&#10;        void BuildAssemblyConstraintGraph();&#10;&#10;        /**&#10;         * @brief Print part/feature counts to the console for quick diagnostics&#10;         */&#10;        void PrintStatistics() const;&#10;&#10;        /**&#10;         * @brief Serialize current analysis data to a JSON file&#10;         * @details Writes part IDs and composite feature summaries in a lightweight interchange format&#10;         * @param filePath input: destination JSON path&#10;         * @return output: true when file writing succeeds, false otherwise&#10;         */&#10;        [[nodiscard]] bool ExportToJSON(const std::string&amp; filePath) const;&#10;&#10;        /**&#10;         * @brief Simple linkage smoke test invoked from legacy entry points&#10;         * @details Currently emits a readiness message to stdout&#10;         */&#10;        static void runTest();&#10;&#10;        /**&#10;        * @brief Check whether the midpoint of a segment between two points lies inside the solid&#10;        * @details Used to distinguish slot vs. tongue by probing material occupancy&#10;        * @param p1 input: first sample point&#10;        * @param p2 input: second sample point&#10;        * @param solid input: solid used for inside-outside test&#10;        * @return output: true if midpoint is inside the solid, otherwise false&#10;        */&#10;        static bool IsMaterialBetween(const gp_Pnt&amp; p1, const gp_Pnt&amp; p2, const TopoDS_Shape&amp; solid);&#10;&#10;        /**&#10;         * @brief Retrieve the current list of inferred assembly constraints&#10;         * @return output: copy of the internal constraint vector&#10;         */&#10;        [[nodiscard]] std::vector&lt;AssemblyConstraint&gt; GetAssemblyConstraints() const { return constraints_; }&#10;&#10;        /**&#10;         * @brief Generate flattened graph data for a specific part ID&#10;         * @details Converts atomic features and adjacency information into arrays consumable by PyG&#10;         * @param partID input: identifier of the part to export&#10;         * @return output: populated DeepLearningGraphData structure (empty if part not found)&#10;         */&#10;        [[nodiscard]] DeepLearningGraphData GetGraphDataForPart(const std::string&amp; partID) const;&#10;&#10;    private:&#10;        // Internal logic helpers (Step 1)&#10;        /**&#10;         * @brief Recursively extract PartNode entries from an XDE label&#10;         * @details Handles both assembly and simple-shape labels while accumulating the applied transformation&#10;         * @param label input: XDE label under inspection&#10;         * @param transformation input: cumulative transformation from parent assemblies&#10;         */&#10;        void ExtractPartsFromLabel(const TDF_Label&amp; label, const gp_Trsf&amp; transformation);&#10;&#10;        // Internal logic helpers (Step 2)&#10;        /**&#10;         * @brief Classify every face in the given part into AtomicFeature records&#10;         * @details Computes geometry, concavity, area, adjacency, and fragment metadata for downstream processing&#10;         * @param partNode input/output: part structure receiving freshly computed atomicFeatures&#10;         */&#10;        void ClassifyPartAtomicFeatures(PartNode&amp; partNode);&#10;&#10;        /**&#10;         * @brief Merge atomic features that belong to the same analytical surface&#10;         * @details Collapses curved fragments into logical groups, assigning shared IDs and accumulated areas&#10;         */&#10;        void MergeFragmentedFeatures() const;&#10;&#10;        /**&#10;         * @brief Inspect the OCC surface backing a face and return its AtomType plus parameters&#10;         * @param face input: face whose geometry is analyzed&#10;         * @return output: pair of AtomType and filled GeometricParams&#10;         */&#10;        static std::pair&lt;AtomType, GeometricParams&gt; IdentifyGeometryType(const TopoDS_Face&amp; face);&#10;&#10;        /**&#10;         * @brief Determine whether a classified face is convex, concave, or neutral&#10;         * @param face input: target face&#10;         * @param atomType input: previously detected surface type&#10;         * @param geomParams input: geometry parameters including center point&#10;         * @param parentSolid input: solid used for inside/outside testing&#10;         * @return output: FormType result describing concavity&#10;         */&#10;        static FormType DetermineConcavity(&#10;            const TopoDS_Face&amp; face, const AtomType&amp; atomType,&#10;            const GeometricParams&amp; geomParams, const TopoDS_Shape&amp; parentSolid);&#10;&#10;        /**&#10;         * @brief Measure the dihedral angle between two faces sharing the same edge&#10;         * @details Evaluates normals at the edge midpoint and returns the angle in radians&#10;         */&#10;        static double ComputeEdgeDihedralAngle(const TopoDS_Edge&amp; edge, const TopoDS_Face&amp; f1, const TopoDS_Face&amp; f2);&#10;&#10;        /**&#10;         * @brief Build an adjacency list for the supplied face within a parent solid&#10;         * @details Iterates over incident edges, locates neighboring faces, and stores continuity and angles&#10;         * @param face input: face under analysis&#10;         * @param faceID input: identifier associated with the face&#10;         * @param parentSolid input: solid needed for edge-to-face mapping&#10;         * @return output: vector of AdjacencyInfo entries&#10;         */&#10;        std::vector&lt;AdjacencyInfo&gt; AnalyzeTopologicalAdjacency(&#10;            const TopoDS_Face&amp; face, const std::string&amp; faceID,&#10;            const TopoDS_Shape&amp; parentSolid);&#10;&#10;        // Internal logic helpers (Step 3)&#10;        // Using shared_ptr for map values to prevent pointer invalidation&#10;        using FeatureMap = std::map&lt;std::string, std::shared_ptr&lt;AtomicFeature&gt;&gt;;&#10;&#10;        /**&#10;         * @brief Recognize hole features composed of concave cylindrical surfaces&#10;         * @details Accepts candidate concave cylinders, optionally merges fragments, and records blind/through metadata&#10;         * @param partNode input/output: part that receives the new composite feature&#10;         * @param feature input: candidate atomic cylinder&#10;         * @param featureMap input/output: lookup table used to mark faces as consumed&#10;         * @return output: true if a hole feature was recognized, otherwise false&#10;         */&#10;        static bool RecognizeHoleFeature(PartNode&amp; partNode, const std::shared_ptr&lt;AtomicFeature&gt;&amp; feature, FeatureMap&amp; featureMap);&#10;&#10;        /**&#10;         * @brief Recognize shaft features composed of convex cylindrical surfaces&#10;         * @details Mirrors the hole logic but for protruding geometry used in mating conditions&#10;         * @param partNode input/output: part that receives the new composite feature&#10;         * @param feature input: candidate atomic cylinder&#10;         * @param featureMap input/output: lookup table used to mark faces as consumed&#10;         * @return output: true if a shaft feature was recognized, otherwise false&#10;         */&#10;        static bool RecognizeShaftFeature(PartNode&amp; partNode, const std::shared_ptr&lt;AtomicFeature&gt;&amp; feature, FeatureMap&amp; featureMap);&#10;&#10;        /**&#10;         * @brief Recognize step planes adjacent to cylindrical features via sharp (C0) edges&#10;         * @details Promotes neutral planes that neighbor cylinders into STEP_PLANE composites&#10;         * @param partNode input/output: owning part&#10;         * @param feature input: candidate atomic plane&#10;         * @param featureMap input/output: map used to find adjacent faces&#10;         * @return output: true if a step plane was recorded, otherwise false&#10;         */&#10;        static bool RecognizeStepPlaneFeature(PartNode&amp; partNode, const std::shared_ptr&lt;AtomicFeature&gt;&amp; feature, FeatureMap&amp; featureMap);&#10;&#10;        /**&#10;         * @brief Recognize functional planes that remain unconsumed yet exceed area/importance thresholds&#10;         * @details Acts as a catch-all to ensure significant planar surfaces are captured for mating relations&#10;         * @param partNode input/output: owning part&#10;         * @param feature input: candidate atomic plane&#10;         * @param featureMap input/output: map used for state tracking&#10;         * @return output: true if the plane was promoted to a composite feature, otherwise false&#10;         */&#10;        static bool RecognizeFunctionalPlaneFeature(PartNode&amp; partNode, const std::shared_ptr&lt;AtomicFeature&gt;&amp; feature,&#10;                                                    FeatureMap&amp; featureMap);&#10;&#10;        /**&#10;         * @brief Compute the surface area of a given face&#10;         * @details Uses BRepGProp to calculate the precise surface area via mass properties&#10;         * @param face input: face whose area is measured&#10;         * @return output: surface area in square units (typically mmÂ²)&#10;         */&#10;        static double ComputeFaceArea(const TopoDS_Face&amp; face);&#10;&#10;        /**&#10;         * @brief Sample a representative point on the face surface&#10;         * @details Evaluates the face at the midpoint of its UV parameter domain&#10;         * @param face input: face from which to extract a sample point&#10;         * @return output: 3D point in world coordinates&#10;         */&#10;        static gp_Pnt GetFaceSamplePoint(const TopoDS_Face&amp; face);&#10;&#10;        /**&#10;         * @brief Measure the height of a cylindrical face along its axis&#10;         * @details Projects all edge vertices onto the axis and computes the span distance&#10;         * @param face input: cylindrical face to measure&#10;         * @param axisPoint input: reference point on the cylinder axis&#10;         * @param axisVector input: direction vector of the cylinder axis&#10;         * @return output: height measured along the axis direction&#10;         */&#10;        static double ComputeCylinderHeight(const TopoDS_Face&amp; face, const gp_Pnt&amp; axisPoint, const gp_Dir&amp; axisVector);&#10;&#10;        /**&#10;         * @brief Evaluate all feature pairs between two parts and record compatible constraints&#10;         * @details Iterates over composite features in both parts and delegates to coaxial/planar matchers&#10;         * @param nodeA input: first part in the pair&#10;         * @param nodeB input: second part in the pair&#10;         */&#10;        void MatchPartPair(const PartNode&amp; nodeA, const PartNode&amp; nodeB);&#10;&#10;        /**&#10;         * @brief Test whether two cylindrical features form a valid coaxial constraint&#10;         * @details Checks axis parallelism, distance from axis, and radius compatibility&#10;         * @param nodeA input: part containing the first feature&#10;         * @param featA input: first cylindrical feature (hole or shaft)&#10;         * @param nodeB input: part containing the second feature&#10;         * @param featB input: second cylindrical feature (hole or shaft)&#10;         */&#10;        void MatchCoaxial(const PartNode&amp; nodeA, const CompositeFeature&amp; featA,&#10;                          const PartNode&amp; nodeB, const CompositeFeature&amp; featB);&#10;&#10;        /**&#10;         * @brief Test whether two planar features form a valid coincident constraint&#10;         * @details Verifies that normals are opposite, planes are co-planar, and bounding boxes overlap&#10;         * @param nodeA input: part containing the first feature&#10;         * @param featA input: first planar feature (functional or step plane)&#10;         * @param nodeB input: part containing the second feature&#10;         * @param featB input: second planar feature (functional or step plane)&#10;         */&#10;        void MatchCoincident(const PartNode&amp; nodeA, const CompositeFeature&amp; featA,&#10;                             const PartNode&amp; nodeB, const CompositeFeature&amp; featB);&#10;&#10;        /**&#10;         * @brief Transform a local axis to world coordinates using the provided transformation&#10;         * @details Applies the gp_Trsf to both the axis location and direction&#10;         * @param localAxis input: axis in part-local coordinates&#10;         * @param trsf input: transformation matrix from local to world space&#10;         * @return output: transformed axis in world coordinates&#10;         */&#10;        static gp_Ax1 TransformAxis(const gp_Ax1&amp; localAxis, const gp_Trsf&amp; trsf);&#10;&#10;        /**&#10;         * @brief Transform a local point to world coordinates using the provided transformation&#10;         * @details Applies the gp_Trsf to the point coordinates&#10;         * @param localPnt input: point in part-local coordinates&#10;         * @param trsf input: transformation matrix from local to world space&#10;         * @return output: transformed point in world coordinates&#10;         */&#10;        static gp_Pnt TransformPoint(const gp_Pnt&amp; localPnt, const gp_Trsf&amp; trsf);&#10;&#10;        /**&#10;         * @brief Transform a local direction vector to world coordinates using the provided transformation&#10;         * @details Applies the gp_Trsf to the direction components (ignores translation)&#10;         * @param localDir input: direction in part-local coordinates&#10;         * @param trsf input: transformation matrix from local to world space&#10;         * @return output: transformed direction in world coordinates&#10;         */&#10;        static gp_Dir TransformDir(const gp_Dir&amp; localDir, const gp_Trsf&amp; trsf);&#10;&#10;        /**&#10;         * @brief Perform broad-phase collision detection between two parts using axis-aligned bounding boxes&#10;         * @details Computes bounding boxes in world space, enlarges by tolerance, and tests for overlap&#10;         * @param nodeA input: first part to test&#10;         * @param nodeB input: second part to test&#10;         * @return output: true if bounding boxes overlap (potential contact), otherwise false&#10;         */&#10;        static bool CheckBoundingBoxCollision(const PartNode&amp; nodeA, const PartNode&amp; nodeB);&#10;&#10;        // Member Data&#10;        Handle(TDocStd_Document) doc_;              // XDE document holding the imported STEP assembly&#10;        Handle(XCAFDoc_ShapeTool) shapeTool_;      // XDE shape tool for navigating the assembly hierarchy&#10;&#10;        std::vector&lt;PartNode&gt; partNodes_;           // Collection of all extracted parts with their features&#10;&#10;        // Custom comparator for using TopoDS_Face as a map key&#10;        struct FaceComparator&#10;        {&#10;            bool operator()(const TopoDS_Face&amp; f1, const TopoDS_Face&amp; f2) const&#10;            {&#10;                // 1. Compare TShape pointers&#10;                if (f1.TShape().get() != f2.TShape().get())&#10;                {&#10;                    return f1.TShape().get() &lt; f2.TShape().get();&#10;                }&#10;&#10;                // 2. Compare Location Hash&#10;                const int h1 = static_cast&lt;int&gt;(f1.Location().HashCode());&#10;&#10;                if (const int h2 = static_cast&lt;int&gt;(f2.Location().HashCode()); h1 != h2)&#10;                {&#10;                    return h1 &lt; h2;&#10;                }&#10;&#10;                // 3. Compare Orientation&#10;                return f1.Orientation() &lt; f2.Orientation();&#10;            }&#10;        };&#10;&#10;        std::map&lt;TopoDS_Face, std::string, FaceComparator&gt; faceIDMap_;  // Bidirectional lookup: face to unique ID&#10;&#10;        /**&#10;         * @brief Store the list of assembly constraints discovered during graph construction&#10;         * @details Populated by BuildAssemblyConstraintGraph and consumed by downstream clients&#10;         */&#10;        std::vector&lt;AssemblyConstraint&gt; constraints_;&#10;    };&#10;} // namespace ASG&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>